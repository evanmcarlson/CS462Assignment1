### graph.py
### an implementation of a graph using an adjacency list.

## helper class representing a node in a graph. For the moment, nodes
## only have names. Later, we will add state variables.

class Node() :
    def __init__(self, n):
        self.name = n

    def __hash__(self):
        return hash(self.name)

### an edge is a link between two nodes. Right now, the only other
### information an edge carries is the weight of the link. Later we
### will add other annotations.

class Edge() :
    def __init__(self, src,dest, weight) :
        self.src = src
        self.dest = dest
        self.weight = weight

### The graph class itself.
### The nodeTable is a dictionary that maps names to Node objects.
### (this keeps us from having to repeatedly search edgeMap.keys())

### The edgeMap is a dictionary that maps nodes to lists of Edges emanating from that node.

class Graph() :

    def __init__(self):
        self.nodeTable = {}
        self.edgeMap = {}

    ### implements the 'in' keyword. Returns true if the node is in the graph.
    def __contains__(self, item):
        return item in self.nodeTable

    def getNode(self, src):
        return nodeList[src]

    def addNode(self, src):
        if src not in self.nodeTable :
            self.nodeTable[src] = Node(src)

    def addEdge(self, src, dest, weight):
        e = Edge(src,dest,weight)
        self.addNode(src)
        self.addNode(dest)
        if src in self.edgeMap :
            self.edgeMap[src].append(e)
        else :
            self.edgeMap[src] = [e]


    ## Assume file is in the mtx format: % is a comment
    ## Otherwise it's source destination weight
    ### The file in the github repo will work as a sample for you.
    ### It's in the format: source, vertex, weight. You should assume that the graph is symmetric -
    ### if there's an edge from a to b, there's an edge from b to a.
    ### You can find lots of others here: http://networkrepository.com/index.php
    def readFromFile(self, fname):
        with open(fname) as f :
            for l in f.readlines() :
                if not l.startswith("%") :
                    (s,d,w) = l.split()
                    self.addEdge(s,d,w)

    ### inputs are the name of a startNode and endNode. Given this,
    ### return a list of Nodes that indicates the path from start to finish, using breadth-first search.

    def breadthFirstSearch(self, startNode, endNode):
        visited = []
        queue = []
        visited.append(startNode)
        queue.append(startNode)

        while queue:
            s = queue.pop(0)
            print(s, end=" ")

            for successor in s:
                if successor not in visited:
                    visited.append(successor)
                    queue.append(successor)

    ### inputs are the name of a startNode and endNode. Given this,
    ### return a list of Nodes that indicates the path from start to finish, using depth-first search.

    def depthFirstSearch(self, startNode, endNode):
        visited = []
        stack = []
        visited.append(startNode)
        stack.append(startNode)

        while stack:
            s = stack.pop()
            print(s, end=" ")

            for successor in s:
                if successor not in visited:
                    visited.append(successor)
                    stack.append(successor)

    ### implement Djikstra's all-pairs shortest-path algorithm.
    ### https://yourbasic.org/algorithms/graph/#dijkstra-s-algorithm
    ### return the array of distances and the array previous nodes.

    def djikstra(self, startNode):
        queue = self.nodeTable
        dist = []
        prev = []
        for vertex in queue:
            dist[vertex] = math.inf
            prev[vertex] = 0
        dist[startNode] = 0
        while queue:
            n = queue.pop(0)
            for neighbor in n:
                if dist[n] + len(n, neighbor) < dist[neighbor]:
                    dist[neighbor] = dist[n] + len(n, neighbor)
                    prev[neighbor] = n
        return dist, prev

    ### takes as input a starting node, and computes the minimum spanning tree, using Prim's algorithm.
    ### https:// en.wikipedia.org/wiki/Prim % 27s_algorithm
    ### you should return a new graph representing the spanning tree generated by Prim's.
    def prim(self, startNode):
        reached = [startNode]
        unreached = self.nodeTable[1:]
        tree = []
        while unreached:
            # choose the adjacent node with the least edge cost
            for u in reached:
                lowestCost = Edge(0, 0, math.inf)
                edges = self.edgeMap.get(u)
                for edge in edges:
                    if edge.weight < lowestCost.weight & edge.dest in unreached:
                        lowestCost = edge
                tree.append(lowestCost)
                reached.append(lowestCost.dest)
                unreached.__delitem__(lowestCost.dest)

    ### 686 students only ###
    ### takes as input a startingNode and returns a list of all nodes in the maximum clique containing this node.
    ### https://en.wikipedia.org/wiki/Clique_problem#Finding_a_single_maximal_clique

    def clique(self, startNode):
        pass